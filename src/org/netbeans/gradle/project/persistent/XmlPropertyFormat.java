package org.netbeans.gradle.project.persistent;

import java.io.File;
import java.io.IOException;
import java.nio.charset.Charset;
import java.nio.charset.IllegalCharsetNameException;
import java.nio.charset.UnsupportedCharsetException;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.OutputKeys;
import javax.xml.transform.Result;
import javax.xml.transform.Source;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import org.netbeans.api.java.platform.JavaPlatform;
import org.netbeans.api.java.platform.JavaPlatformManager;
import org.netbeans.gradle.project.properties.MemProjectProperties;
import org.netbeans.gradle.project.properties.PropertiesSnapshot;
import org.openide.modules.SpecificationVersion;
import org.w3c.dom.Comment;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;

final class XmlPropertyFormat {
    private static final Logger LOGGER = Logger.getLogger(XmlPropertyFormat.class.getName());

    private static final String ROOT_NODE = "gradle-project-properties";
    private static final String SOURCE_ENCODING_NODE = "source-encoding";
    private static final String PLATFORM_NODE = "target-platform";
    private static final String SOURCE_LEVEL_NODE = "source-level";

    private static void addSimpleChild(Node parent, String tagName, String value) {
        Element element = parent.getOwnerDocument().createElement(tagName);
        element.setTextContent(value);
        parent.appendChild(element);
    }

    private static void saveDocument(File propertyfile, Document document) throws TransformerException, IOException {
        Source source = new DOMSource(document);
        Result result = new StreamResult(propertyfile);

        Transformer transformer = TransformerFactory.newInstance().newTransformer();
        transformer.setOutputProperty(OutputKeys.ENCODING, "UTF-8");
        transformer.setOutputProperty("{http://xml.apache.org/xslt}indent-amount", "2");
        transformer.setOutputProperty(OutputKeys.INDENT, "yes");

        transformer.transform(source, result);
    }

    public static void saveToXml(File propertyfile, PropertiesSnapshot snapshot) {
        if (propertyfile == null) throw new NullPointerException("propertyfile");
        if (snapshot == null) throw new NullPointerException("snapshot");

        DocumentBuilder builder;
        try {
            builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();
        } catch (ParserConfigurationException ex) {
            LOGGER.log(Level.SEVERE, "Failed to create XML builder.", ex);
            return;
        }

        Document document = builder.newDocument();
        Element root = document.createElement(ROOT_NODE);
        document.appendChild(root);

        Comment comment = document.createComment(
                "DO NOT EDIT THIS FILE!"
                + " - Used by the Gradle plugin of NetBeans.");
        root.appendChild(comment);

        JavaPlatform defaultPlatform = JavaPlatform.getDefault();

        String sourceEncoding = snapshot.getSourceEncoding().name();
        if (!sourceEncoding.equals(MemProjectProperties.DEFAULT_SOURCE_ENCODING.name())) {
            addSimpleChild(root, SOURCE_ENCODING_NODE, sourceEncoding);
        }

        JavaPlatform platform = snapshot.getPlatform();
        if (!platform.equals(defaultPlatform)) {
            addSimpleChild(root, PLATFORM_NODE, platform.getSpecification().getVersion().toString());
        }

        String sourceLevel = snapshot.getSourceLevel();
        if (!sourceLevel.equals(MemProjectProperties.getSourceLevelFromPlatform(defaultPlatform))) {
            addSimpleChild(root, SOURCE_LEVEL_NODE, sourceLevel);
        }

        try {
            saveDocument(propertyfile, document);
        } catch (IOException ex) {
            LOGGER.log(Level.INFO, "Failed to save the properties.", ex);
        } catch (TransformerException ex) {
            LOGGER.log(Level.INFO, "Failed to save the properties.", ex);
        }
    }

    private static String tryGetValueOfNode(Node node, String tagName) {
        NodeList childNodes = node.getChildNodes();
        int childCount = childNodes.getLength();
        for (int i = 0; i < childCount; i++) {
            Node child = childNodes.item(i);
            if (tagName.equals(child.getNodeName())) {
                String result = child.getTextContent();
                return result != null ? result.trim() : null;
            }
        }
        return null;
    }


    private static Charset parseCharset(String name) {
        try {
            return Charset.forName(name);
        } catch (IllegalCharsetNameException ex) {
            LOGGER.log(Level.INFO, "The name of the character set is invalid: " + name, ex);
        } catch (UnsupportedCharsetException ex) {
            LOGGER.log(Level.INFO, "The character set is not supported: " + name, ex);
        }

        return null;
    }

    private static JavaPlatform parsePlatform(String versionStr) {
        SpecificationVersion version;
        try {
            version = new SpecificationVersion(versionStr);
        } catch (NumberFormatException ex) {
            LOGGER.log(Level.INFO, "Invalid platform version: " + versionStr, ex);
            return null;
        }

        JavaPlatform[] platforms = JavaPlatformManager.getDefault().getInstalledPlatforms();
        for (JavaPlatform platform: platforms) {
            if (version.equals(platform.getSpecification().getVersion())) {
                return platform;
            }
        }

        // We could not find an exact match, so try to find the best match:
        //
        // 1. If there is at least one platform with a version higher than
        //    requested, choose the one with the lowest version which is still
        //    higher than the requested (the closest version to the requested
        //    which is above the requested version).
        //
        // 2. In case every platform is below the requested, choose the one
        //    with the highest version number.

        JavaPlatform bestMatch = null;
        for (JavaPlatform platform: platforms) {
            if (bestMatch == null) {
                bestMatch = platform;
            }
            else {
                SpecificationVersion bestVersion = bestMatch.getSpecification().getVersion();
                SpecificationVersion thisVersion = platform.getSpecification().getVersion();

                // required version is greater than the one we currently have
                if (version.compareTo(bestVersion) > 0) {
                    // Replace if this platform has a greater version number
                    if (bestVersion.compareTo(thisVersion) < 0) {
                        bestMatch = platform;
                    }
                }
                else {
                    // Replace if this platform is still above the requirement
                    // but is below the one we currently have.
                    if (version.compareTo(thisVersion) < 0
                            && thisVersion.compareTo(bestVersion) < 0) {
                        bestMatch = platform;
                    }
                }
            }
        }

        if (bestMatch == null) {
            LOGGER.severe("Could not find any Java platform.");
        }
        else if (version.compareTo(bestMatch.getSpecification().getVersion()) > 0) {
            LOGGER.log(Level.WARNING,
                    "The choosen platform has a higher version number than the requested one: {0}",
                    versionStr);
        }
        else {
            LOGGER.log(Level.WARNING,
                    "The choosen platform has a lower version number than the requested one: {0}",
                    versionStr);
        }
        return bestMatch;
    }

    public static PropertiesSnapshot readFromXml(File propertiesFile) {
        PropertiesSnapshot.Builder result = new PropertiesSnapshot.Builder();

        DocumentBuilder builder;
        try {
            builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();
        } catch (ParserConfigurationException ex) {
            LOGGER.log(Level.SEVERE, "Failed to create XML builder.", ex);
            return result.create();
        }

        Document document;
        try {
            if (!propertiesFile.exists()) {
                return result.create();
            }

            document = builder.parse(propertiesFile);
        } catch (SAXException ex) {
            LOGGER.log(Level.INFO, "Failed to parse the property file.", ex);
            return result.create();
        } catch (IOException ex) {
            LOGGER.log(Level.INFO, "Failed to read the property file.", ex);
            return result.create();
        }

        Element root = document.getDocumentElement();

        String sourceLevel = tryGetValueOfNode(root, SOURCE_LEVEL_NODE);
        if (sourceLevel != null) {
            result.setSourceLevel(sourceLevel);
        }

        String sourceEncodingStr = tryGetValueOfNode(root, SOURCE_ENCODING_NODE);
        Charset sourceEncoding = sourceEncodingStr != null
                ? parseCharset(sourceEncodingStr)
                : null;
        if (sourceEncoding != null) {
            result.setSourceEncoding(sourceEncoding);
        }

        String platformStr = tryGetValueOfNode(root, PLATFORM_NODE);
        JavaPlatform platform = platformStr != null
                ? parsePlatform(platformStr)
                : null;
        if (platform != null) {
            result.setPlatform(platform);
        }

        return result.create();
    }

    private XmlPropertyFormat() {
        throw new AssertionError();
    }
}
