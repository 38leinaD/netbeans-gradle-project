import org.gradle.api.tasks.JavaExec
import org.gradle.api.tasks.testing.Test

afterProject { org.gradle.api.Project project ->
    if (project == null) {
        return;
    }

    def tasks = project.tasks
    boolean hasRun = tasks.findByName('run') != null
    boolean hasDebug = tasks.findByName('debug') != null

    List debuggerAttachArgs = null;
    if (project.hasProperty('debuggerJpdaPort')) {
        def debuggerPort = project.debuggerJpdaPort
        debuggerAttachArgs = ['-Xdebug', "-Xrunjdwp:transport=dt_socket,server=n,address=${debuggerPort}".toString()]
    }

    if (tasks.findByName('classes') != null && project.hasProperty('sourceSets')) {
        def definedMainClass = project.hasProperty('mainClass') ? project.mainClass : ''
        if (definedMainClass == null) definedMainClass = '';
        definedMainClass = definedMainClass.toString()

        def configJavaExec = { JavaExec task ->
            task.main = definedMainClass
            task.classpath = project.sourceSets.main.runtimeClasspath
            task.standardInput = System.in
        }

        if (!hasRun) {
            if ('' != definedMainClass) {
                project.task ('run', dependsOn: project.classes, type: JavaExec) {
                    configJavaExec(it)
                }
            }
            else {
                project.task('run').doLast {
                    println 'Cannot execute run because the property "mainClass" is not defined or empty.'
                }
            }
        }

        if (!hasDebug) {
            if ('' != definedMainClass) {
                project.task ('debug', dependsOn: project.classes, type: JavaExec) {
                    configJavaExec(it)
                    debug = true
                }
            }
            else {
                project.task('debug').doLast {
                    println 'Cannot execute debug because the property "mainClass" is not defined or empty.'
                }
            }
        }
    }
    else {
        if (!hasRun) {
            project.task('run').doLast {
                println 'Cannot execute run because the project does not have classes or source sets.'
            }
        }
        if (!hasDebug) {
            project.task('debug').doLast {
                println 'Cannot execute debug because the project does not have classes or source sets.'
            }
        }
    }

    if (debuggerAttachArgs != null && project.hasProperty('debuggedTaskName')) {
        def debuggedTaskName = project.debuggedTaskName.toString()

        def task = debuggedTaskName.indexOf(':') >= 0 ? project.rootProject.tasks.findByPath(debuggedTaskName) : project.tasks.findByName(debuggedTaskName)
        if (task?.project == project) {
            if ((task instanceof JavaExec) || (task instanceof Test)) {
                updateJvmArgs(task, debuggerAttachArgs)
            }
        }
    }
}

void updateJvmArgs(def task, List additionalArgs) {
    // Note: The list might contain non-string instances, so first convert them.
    Set additionalArgsSet = new LinkedHashSet(additionalArgs*.toString())
    List currentArgs = task.jvmArgs;
    for (def arg: task.jvmArgs) {
        additionalArgsSet.remove(arg?.toString())
    }
    task.jvmArgs(additionalArgsSet)
}
