import org.gradle.api.tasks.JavaExec
import org.gradle.api.tasks.testing.Test

afterProject { org.gradle.api.Project project ->
    if (project == null) {
        return;
    }

    def tasks = project.tasks
    boolean hasRun = tasks.findByName('run') != null
    boolean hasDebug = tasks.findByName('debug') != null

    if (tasks.findByName('classes') != null && project.hasProperty('sourceSets')) {
        def definedMainClass = project.hasProperty('mainClass') ? project.mainClass : ''
        if (definedMainClass == null) definedMainClass = '';
        definedMainClass = definedMainClass.toString()

        def configJavaExec = { JavaExec task ->
            task.main = definedMainClass
            task.classpath = project.sourceSets.main.runtimeClasspath
            task.standardInput = System.in
        }

        if (!hasRun) {
            if ('' != definedMainClass) {
                project.task ('run', dependsOn: project.classes, type: JavaExec) {
                    configJavaExec(it)
                }
            }
            else {
                project.task('run').doLast {
                    println 'Cannot execute run because the property "mainClass" is not defined or empty.'
                }
            }
        }

        if (!hasDebug) {
            if ('' != definedMainClass) {
                project.task ('debug', dependsOn: project.classes, type: JavaExec) {
                    configJavaExec(it)
                    debug = true
                }
            }
            else {
                project.task('debug').doLast {
                    println 'Cannot execute debug because the property "mainClass" is not defined or empty.'
                }
            }
        }
    }
    else {
        if (!hasRun) {
            project.task('run').doLast {
                println 'Cannot execute run because the project does not have classes or source sets.'
            }
        }
        if (!hasDebug) {
            project.task('debug').doLast {
                println 'Cannot execute debug because the project does not have classes or source sets.'
            }
        }
    }

    if (project.hasProperty('enableJacocoXmlReport') &&  project.plugins.hasPlugin('jacoco')) {
        String enableXml = project.enableJacocoXmlReport?.toString();
        if (enableXml != null && enableXml.equalsIgnoreCase('true')) {
            def task = project.tasks.findByName('jacocoTestReport')
            if (task != null) {
                task.reports.xml.enabled true
            }
        }
    }

    updateDebugTaskArgs(project)
}

void updateDebugTaskArgs(def project) {
    List debuggerAttachArgs = null;
    if (project.hasProperty('debuggerJpdaPort')) {
        def debuggerPort = project.debuggerJpdaPort
        debuggerAttachArgs = ['-Xdebug', "-Xrunjdwp:transport=dt_socket,server=n,address=${debuggerPort}".toString()]
    }

    if (debuggerAttachArgs == null || !project.hasProperty('debuggedTaskName')) {
        return
    }

    String debuggedTaskName = project.debuggedTaskName.toString()
    String localTaskName = debuggedTaskName

    int projectPathSepIndex = debuggedTaskName.lastIndexOf(':')
    if (projectPathSepIndex >= 0) {
        String projectPath = normalizePath(debuggedTaskName.substring(0, projectPathSepIndex).trim())
        if (projectPath != project.path) {
            return
        }

        localTaskName = debuggedTaskName.substring(projectPathSepIndex + 1).trim()
    }

    def task = project.tasks.findByName(localTaskName)
    if ((task instanceof JavaExec) || (task instanceof Test)) {
        updateJvmArgs(task, debuggerAttachArgs)
    }
}

String normalizePath(String rawPath) {
    boolean changed = false

    StringBuilder result = new StringBuilder(rawPath.length())
    if (!rawPath.startsWith(':')) {
        result.append(':')
        changed = true
    }

    boolean prevColon = false
    for (int i = 0; i < rawPath.length(); i++) {
        char ch = rawPath.getAt(i)
        boolean colon = ch == ':'
        if (!colon || !prevColon) {
            result.append(ch)
        }
        else {
            changed = true
        }
        prevColon = colon
    }

    return changed ? result.toString() : rawPath
}

void updateJvmArgs(def task, List additionalArgs) {
    // Note: The list might contain non-string instances, so first convert them.
    Set additionalArgsSet = new LinkedHashSet(additionalArgs*.toString())
    List currentArgs = task.jvmArgs;
    for (def arg: task.jvmArgs) {
        additionalArgsSet.remove(arg?.toString())
    }
    task.jvmArgs(additionalArgsSet)
}
